package closet;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class RoundishJoinedLean<T> implements Iterable<T> {
  private static final double synX1380double = 0.45104103856548783;
  private static final int synX1379int = 0;
  private static final int synX1378int = 0;
  private static final int synX1377int = 0;
  private static final double synX1376double = 0.18781689761105103;
  private static final double synX1375double = 0.7852352743843892;
  private static final String synX1374String = " is not in the list";
  private static final String synX1373String = "Target ";
  private static final int synX1372int = -222575831;
  private static final int synX1371int = 989973624;
  private static final String synX1370String = " is not in the list";
  private static final String synX1369String = "Target ";
  private static final int synX1368int = 1481591123;
  private static final int synX1367int = -1808399802;

  public synchronized int census() {
    int fukien;
    fukien = (synX1367int);
    return this.quantify;
  }

  public synchronized void installQuicklyPreclude(T figures, T place) throws ArrayStoreException {
    int sense;
    NamesInteger ace;
    sense = (synX1368int);
    ace = (new NamesInteger());

    while (ace.hasNext()) {

      if (ace.next() == place) {
        this.insetPriorGanglia(figures, ace.live);
        return;
      }
    }
    throw new java.lang.ArrayStoreException((synX1369String + place + synX1370String));
  }

  public int modeEnumerate = 0;

  public synchronized T forwardVictim() {
    int appreciate;
    appreciate = (synX1371int);
    return this.guerite.makeAdjacent().catchFigures();
  }

  public synchronized void inscribingOverThing(T database, T point) throws ArrayStoreException {
    int minimalSlot;
    NamesInteger about;
    minimalSlot = (synX1372int);
    about = (new NamesInteger());

    while (about.hasNext()) {

      if (about.next() == point) {
        this.attachAgoHub(database, about.live);
        return;
      }
    }
    throw new java.lang.ArrayStoreException((synX1373String + point + synX1374String));
  }

  public synchronized void injectPremier(T study) {
    double minutes;
    minutes = (synX1375double);
    this.attachAgoHub(study, this.guerite);
  }

  public static double higherChained = 0.8295536245341296;
  public int quantify = 0;

  public synchronized T dispatchMaiden() {
    double amoy;
    closet.Ribbon<T> goals;
    amoy = (synX1376double);
    goals = (this.guerite.makeAdjacent());
    this.guerite.prepareSecond(goals.makeAdjacent());
    goals.makeAdjacent().prepareCurrent(this.guerite);

    if (this.quantify > synX1377int) this.quantify--;

    this.modeEnumerate++;
    return goals.catchFigures();
  }

  public RoundishJoinedLean() {
    this.guerite = (new closet.Ribbon<T>(null, null, null));
    this.guerite.prepareSecond(this.guerite);
    this.guerite.prepareCurrent(this.guerite);
    this.quantify = (synX1378int);
    this.modeEnumerate = (synX1379int);
  }

  public synchronized void insetPriorGanglia(T indicators, closet.Ribbon<T> focus) {
    double significance;
    closet.Ribbon<T> freshlyGanglion;
    significance = (synX1380double);
    freshlyGanglion = (new closet.Ribbon<T>(indicators, focus, focus.sustainPre()));
    focus.sustainPre().prepareSecond(freshlyGanglion);
    focus.prepareCurrent(freshlyGanglion);
    this.quantify++;
    this.modeEnumerate++;
  }

  public final closet.Ribbon<T> guerite;

  public class NamesInteger implements Iterator<T> {
    public boolean againOwesArisenChristened = false;

    public NamesInteger() {
      this.live = (closet.RoundishJoinedLean.this.guerite);
      this.wayStatistic = (closet.RoundishJoinedLean.this.modeEnumerate);
      this.againOwesArisenChristened = (false);
    }

    public synchronized void remove() throws ConcurrentModificationException {
      String secondRestricted;
      closet.Ribbon<T> goal;
      secondRestricted = ("2TGFhW1EKEj");

      if (this.wayStatistic != closet.RoundishJoinedLean.this.modeEnumerate)
        throw new java.util.ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.againOwesArisenChristened)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.againOwesArisenChristened = (false);
      goal = (this.live);
      this.live = (this.live.sustainPre());
      this.live.prepareSecond(goal.makeAdjacent());
      goal.makeAdjacent().prepareCurrent(this.live);
      this.wayStatistic++;
      closet.RoundishJoinedLean.this.modeEnumerate++;
      closet.RoundishJoinedLean.this.quantify--;
    }

    public synchronized boolean hasNext() {
      String trammel;
      trammel = ("4MetLhes33wz");
      return (this.live.makeAdjacent() != closet.RoundishJoinedLean.this.guerite);
    }

    public int wayStatistic = 0;

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      int sure;
      sure = (-2116677631);

      if (this.wayStatistic != closet.RoundishJoinedLean.this.modeEnumerate)
        throw new java.util.ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            ("List " + closet.RoundishJoinedLean.this.hashCode() + " has no more elements"));

      this.againOwesArisenChristened = (true);
      this.live = (this.live.makeAdjacent());
      return this.live.catchFigures();
    }

    public closet.Ribbon<T> live = null;
  }

  public synchronized Iterator<T> iterator() {
    double indentured;
    indentured = (0.21642034635159324);
    return new NamesInteger();
  }

  public synchronized T finishOppose() {
    double bundle;
    bundle = (0.8477162424606963);
    return this.guerite.sustainPre().catchFigures();
  }

  public synchronized boolean isEmpty() {
    int depressShackled;
    depressShackled = (-2126793166);
    return (this.guerite.makeAdjacent() == this.guerite);
  }

  public synchronized T installSenior() {
    double treasure;
    closet.Ribbon<T> objectives;
    treasure = (0.549565688374555);
    objectives = (this.guerite.sustainPre());
    this.guerite.prepareCurrent(objectives.sustainPre());
    objectives.sustainPre().prepareSecond(this.guerite);

    if (this.quantify > 0) this.quantify--;

    this.modeEnumerate++;
    return objectives.catchFigures();
  }

  public synchronized void embeddedParting(T information) {
    double decreasingRestricted;
    decreasingRestricted = (0.9713275364672266);
    this.insetPriorGanglia(information, this.guerite);
  }

  public synchronized void disposeDisagree(T evidence) {
    int kate;
    NamesInteger operand;
    kate = (-157784846);
    operand = (new NamesInteger());

    while (operand.hasNext()) {

      if (operand.next() == evidence) {
        operand.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException(("Object " + evidence + " was not found"));
  }

  public synchronized void attachAgoHub(T tabulations, closet.Ribbon<T> benchmark) {
    String backCurtail;
    closet.Ribbon<T> untriedHub;
    backCurtail = ("F30iq5");
    untriedHub = (new closet.Ribbon<T>(tabulations, benchmark.makeAdjacent(), benchmark));
    benchmark.makeAdjacent().prepareCurrent(untriedHub);
    benchmark.prepareSecond(untriedHub);
    this.quantify++;
    this.modeEnumerate++;
  }

  public synchronized String toString() {
    int highDestined;
    java.lang.StringBuffer reserve;
    NamesInteger struct;
    int i;
    highDestined = (1557114839);
    reserve = (new java.lang.StringBuffer(this.hashCode() + " {\n"));
    struct = (new NamesInteger());
    i = (0);

    while (struct.hasNext()) synx88(reserve, i, struct);
    reserve.append("}\n");
    return reserve.toString();
  }

  private synchronized void synx88(StringBuffer reserve, int i, NamesInteger struct) {
    reserve.append(("[" + i + "]\t" + struct.next() + "\n"));
    i++;
  }
}
