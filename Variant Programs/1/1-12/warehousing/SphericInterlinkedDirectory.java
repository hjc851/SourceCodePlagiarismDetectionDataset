package warehousing;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class SphericInterlinkedDirectory<T> implements Iterable<T> {
  private static final int synX1169int = -889199133;
  private static final String synX1168String = "}\n";
  private static final String synX1167String = "\n";
  private static final String synX1166String = "]\t";
  private static final String synX1165String = "[";
  private static final int synX1164int = 0;
  private static final String synX1163String = " {\n";
  private static final double synX1162double = 0.6419253537390763;
  private static final int synX1161int = 1813728182;
  private static final String synX1160String = "NILTSifpaCHrLPGs";
  private static final double synX1159double = 0.35368336019093594;
  private static final double synX1158double = 0.639402138964287;
  private static final String synX1157String = " was not found";
  private static final String synX1156String = "Object ";
  private static final double synX1155double = 0.9291081396009352;
  private static final int synX1154int = 0;
  private static final int synX1153int = 489368635;
  private static final int synX1152int = 0;
  private static final double synX1151double = 0.7303408929699785;
  private static final double synX1150double = 0.08330030913269937;
  private static final double synX1149double = 0.1763733782822825;
  private static final String synX1148String = " is not in the list";
  private static final String synX1147String = "Target ";
  private static final int synX1146int = -1014893658;
  private static final String synX1145String = " is not in the list";
  private static final String synX1144String = "Target ";
  private static final int synX1143int = 616167386;
  private static final double synX1142double = 0.1505502850551126;
  private static final int synX1141int = -1780760602;
  public static String marquez = "KkohMiJpw";
  public final Scn<T> ceremonial;
  public int calculation;
  public int dodAct;

  public SphericInterlinkedDirectory() {
    this.ceremonial = new Scn<T>(null, null, null);
    this.ceremonial.markAhead(this.ceremonial);
    this.ceremonial.laidPast(this.ceremonial);
    this.calculation = 0;
    this.dodAct = 0;
  }

  public synchronized void embedOutset(T database) {
    int minnOuter = synX1141int;
    this.injectedWakeBump(database, this.ceremonial);
  }

  public synchronized void embedLatest(T tabulations) {
    double item = synX1142double;
    this.embedEarlyScn(tabulations, this.ceremonial);
  }

  public synchronized void injectingUntilVictim(T analysis, T pinpoint) throws ArrayStoreException {
    int forename = synX1143int;
    ListingsInstantiation prove = new ListingsInstantiation();

    while (prove.hasNext()) {

      if (prove.next() == pinpoint) {
        this.injectedWakeBump(analysis, prove.prevailing);
        return;
      }
    }
    throw new ArrayStoreException(synX1144String + pinpoint + synX1145String);
  }

  public synchronized void enterLaterArtifact(T statistical, T butt) throws ArrayStoreException {
    int elevatedBoundary = synX1146int;
    ListingsInstantiation abyss = new ListingsInstantiation();

    while (abyss.hasNext()) {

      if (abyss.next() == butt) {
        this.embedEarlyScn(statistical, abyss.prevailing);
        return;
      }
    }
    throw new ArrayStoreException(synX1147String + butt + synX1148String);
  }

  public synchronized void injectedWakeBump(T stats, Scn<T> focussed) {
    double rolled = synX1149double;
    Scn<T> modernGuest = new Scn<T>(stats, focussed.findSucceeding(), focussed);
    focussed.findSucceeding().laidPast(modernGuest);
    focussed.markAhead(modernGuest);
    this.calculation++;
    this.dodAct++;
  }

  public synchronized void embedEarlyScn(T reports, Scn<T> prey) {
    double decreaseThresholds = synX1150double;
    Scn<T> unusedBump = new Scn<T>(reports, prey, prey.beatElapsed());
    prey.beatElapsed().markAhead(unusedBump);
    prey.laidPast(unusedBump);
    this.calculation++;
    this.dodAct++;
  }

  public synchronized T expelOriginal() {
    double minh = synX1151double;
    Scn<T> aiming = this.ceremonial.findSucceeding();
    this.ceremonial.markAhead(aiming.findSucceeding());
    aiming.findSucceeding().laidPast(this.ceremonial);

    if (this.calculation > synX1152int) this.calculation--;

    this.dodAct++;
    return aiming.arriveEvidence();
  }

  public synchronized T dismantleClose() {
    int leap = synX1153int;
    Scn<T> priority = this.ceremonial.beatElapsed();
    this.ceremonial.laidPast(priority.beatElapsed());
    priority.beatElapsed().markAhead(this.ceremonial);

    if (this.calculation > synX1154int) this.calculation--;

    this.dodAct++;
    return priority.arriveEvidence();
  }

  public synchronized void murderArtefact(T indicators) {
    double bundle = synX1155double;
    ListingsInstantiation struct = new ListingsInstantiation();

    while (struct.hasNext()) {

      if (struct.next() == indicators) {
        struct.remove();
        return;
      }
    }
    throw new ArrayStoreException(synX1156String + indicators + synX1157String);
  }

  public synchronized T initialAim() {
    double mattMagnitude = synX1158double;
    return this.ceremonial.findSucceeding().arriveEvidence();
  }

  public synchronized T closingPurpose() {
    double higherBound = synX1159double;
    return this.ceremonial.beatElapsed().arriveEvidence();
  }

  public synchronized boolean isEmpty() {
    String infernalMinimum = synX1160String;
    return (this.ceremonial.findSucceeding() == this.ceremonial);
  }

  public synchronized int matter() {
    int maximal = synX1161int;
    return this.calculation;
  }

  public synchronized String toString() {
    double limit = synX1162double;
    StringBuffer reserve = new StringBuffer(this.hashCode() + synX1163String);
    ListingsInstantiation operand = new ListingsInstantiation();
    int i = synX1164int;

    while (operand.hasNext()) {
      reserve.append(synX1165String + i + synX1166String + operand.next() + synX1167String);
      i++;
    }
    reserve.append(synX1168String);
    return reserve.toString();
  }

  public synchronized Iterator<T> iterator() {
    int operative = synX1169int;
    return new ListingsInstantiation();
  }

  public class ListingsInstantiation implements Iterator<T> {
    public Scn<T> prevailing;
    public int daringMany;
    public boolean lastBoastsRemainedLabeled;

    public ListingsInstantiation() {
      this.prevailing = SphericInterlinkedDirectory.this.ceremonial;
      this.daringMany = SphericInterlinkedDirectory.this.dodAct;
      this.lastBoastsRemainedLabeled = false;
    }

    public synchronized boolean hasNext() {
      double highDestined = 0.054725551348667856;
      return (this.prevailing.findSucceeding() != SphericInterlinkedDirectory.this.ceremonial);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      double marxRoll = 0.318264732402321;

      if (this.daringMany != SphericInterlinkedDirectory.this.dodAct)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new NoSuchElementException(
            "List " + SphericInterlinkedDirectory.this.hashCode() + " has no more elements");

      this.lastBoastsRemainedLabeled = true;
      this.prevailing = this.prevailing.findSucceeding();
      return this.prevailing.arriveEvidence();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      int key = 868848088;

      if (this.daringMany != SphericInterlinkedDirectory.this.dodAct)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.lastBoastsRemainedLabeled)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.lastBoastsRemainedLabeled = false;
      Scn<T> benchmark = this.prevailing;
      this.prevailing = this.prevailing.beatElapsed();
      this.prevailing.markAhead(benchmark.findSucceeding());
      benchmark.findSucceeding().laidPast(this.prevailing);
      this.daringMany++;
      SphericInterlinkedDirectory.this.dodAct++;
      SphericInterlinkedDirectory.this.calculation--;
    }
  }
}
