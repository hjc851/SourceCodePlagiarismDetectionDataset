package disk;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class FlierAttributedShortlist<T> implements Iterable<T> {
  private static final String synX1746String = "OEhKlvQNcnV6JDL";
  private static final String synX1745String = "}\n";
  private static final String synX1744String = "\n";
  private static final String synX1743String = "]\t";
  private static final String synX1742String = "[";
  private static final int synX1741int = 0;
  private static final String synX1740String = " {\n";
  private static final double synX1739double = 0.062006113741387536;
  private static final int synX1738int = -275435513;
  private static final int synX1737int = -1845575083;
  private static final String synX1736String = "Pmu";
  private static final double synX1735double = 0.06424897942607077;
  private static final String synX1734String = " was not found";
  private static final String synX1733String = "Object ";
  private static final int synX1732int = -207169525;
  private static final int synX1731int = 0;
  private static final int synX1730int = -810958728;
  private static final int synX1729int = 0;
  private static final String synX1728String = "nmmhdJc8XwjLqF";
  private static final double synX1727double = 0.2827093623984894;
  private static final String synX1726String = "yGstk";
  private static final String synX1725String = " is not in the list";
  private static final String synX1724String = "Target ";
  private static final double synX1723double = 0.19350910699486357;
  private static final String synX1722String = " is not in the list";
  private static final String synX1721String = "Target ";
  private static final double synX1720double = 0.5904948662421367;
  private static final double synX1719double = 0.47518407452714007;
  private static final int synX1718int = 202240883;
  public int neoCount;
  public int reckoning;
  public final Nodule<T> surveillance;
  static double fullThick = 0.017497884986620416;

  public FlierAttributedShortlist() {
    this.surveillance = new Nodule<T>(null, null, null);
    this.surveillance.layIncoming(this.surveillance);
    this.surveillance.markRecent(this.surveillance);
    this.reckoning = 0;
    this.neoCount = 0;
  }

  public synchronized void putKickoff(T computer) {
    int frownObligated;
    frownObligated = synX1718int;
    this.injectedWakeBump(computer, this.surveillance);
  }

  public synchronized void infixEnd(T records) {
    double enumeration;
    enumeration = synX1719double;
    this.incorporatedNeverIssue(records, this.surveillance);
  }

  public synchronized void pasteLateTotem(T databases, T pinpoint) throws ArrayStoreException {
    double treasure;
    RosterInitialise magic;
    treasure = synX1720double;
    magic = new RosterInitialise();

    while (magic.hasNext()) {

      if (magic.next() == pinpoint) {
        this.injectedWakeBump(databases, magic.rife);
        return;
      }
    }
    throw new ArrayStoreException(synX1721String + pinpoint + synX1722String);
  }

  public synchronized void incloseUntilObjection(T study, T focussed) throws ArrayStoreException {
    double taiwaneseThickness;
    RosterInitialise gift;
    taiwaneseThickness = synX1723double;
    gift = new RosterInitialise();

    while (gift.hasNext()) {

      if (gift.next() == focussed) {
        this.incorporatedNeverIssue(study, gift.rife);
        return;
      }
    }
    throw new ArrayStoreException(synX1724String + focussed + synX1725String);
  }

  public synchronized void injectedWakeBump(T numbers, Nodule<T> objective) {
    String lot;
    Nodule<T> originalAntenna;
    lot = synX1726String;
    originalAntenna = new Nodule<T>(numbers, objective.goFuture(), objective);
    objective.goFuture().markRecent(originalAntenna);
    objective.layIncoming(originalAntenna);
    this.reckoning++;
    this.neoCount++;
  }

  public synchronized void incorporatedNeverIssue(T indicators, Nodule<T> focused) {
    double trammel;
    Nodule<T> newbornIssue;
    trammel = synX1727double;
    newbornIssue = new Nodule<T>(indicators, focused, focused.comePast());
    focused.comePast().layIncoming(newbornIssue);
    focused.markRecent(newbornIssue);
    this.reckoning++;
    this.neoCount++;
  }

  public synchronized T reinstallLow() {
    String kesThings;
    Nodule<T> goal;
    kesThings = synX1728String;
    goal = this.surveillance.goFuture();
    this.surveillance.layIncoming(goal.goFuture());
    goal.goFuture().markRecent(this.surveillance);

    if (this.reckoning > synX1729int) this.reckoning--;

    this.neoCount++;
    return goal.fetchTabulations();
  }

  public synchronized T slayFinal() {
    int quality;
    Nodule<T> prey;
    quality = synX1730int;
    prey = this.surveillance.comePast();
    this.surveillance.markRecent(prey.comePast());
    prey.comePast().layIncoming(this.surveillance);

    if (this.reckoning > synX1731int) this.reckoning--;

    this.neoCount++;
    return prey.fetchTabulations();
  }

  public synchronized void takeObjective(T measurements) {
    int sense;
    RosterInitialise uniterable;
    sense = synX1732int;
    uniterable = new RosterInitialise();

    while (uniterable.hasNext()) {

      if (uniterable.next() == measurements) {
        uniterable.remove();
        return;
      }
    }
    throw new ArrayStoreException(synX1733String + measurements + synX1734String);
  }

  public synchronized T freshmanDemur() {
    double constitute;
    constitute = synX1735double;
    return this.surveillance.goFuture().fetchTabulations();
  }

  public synchronized T latestCavil() {
    String morin;
    morin = synX1736String;
    return this.surveillance.comePast().fetchTabulations();
  }

  public synchronized boolean isEmpty() {
    int obligated;
    obligated = synX1737int;
    return (this.surveillance.goFuture() == this.surveillance);
  }

  public synchronized int matter() {
    int juniorRestriction;
    juniorRestriction = synX1738int;
    return this.reckoning;
  }

  public synchronized String toString() {
    double thresholds;
    StringBuffer extra;
    RosterInitialise pathname;
    int i;
    thresholds = synX1739double;
    extra = new StringBuffer(this.hashCode() + synX1740String);
    pathname = new RosterInitialise();
    i = synX1741int;

    while (pathname.hasNext()) {
      extra.append(synX1742String + i + synX1743String + pathname.next() + synX1744String);
      i++;
    }
    extra.append(synX1745String);
    return extra.toString();
  }

  public synchronized Iterator<T> iterator() {
    String identity;
    identity = synX1746String;
    return new RosterInitialise();
  }

  public class RosterInitialise implements Iterator<T> {
    public boolean incomingMaintainsGoneReferred;
    public int daringMany;
    public Nodule<T> rife;

    public RosterInitialise() {
      this.rife = FlierAttributedShortlist.this.surveillance;
      this.daringMany = FlierAttributedShortlist.this.neoCount;
      this.incomingMaintainsGoneReferred = false;
    }

    public synchronized boolean hasNext() {
      int northernObligated;
      northernObligated = -247350322;
      return (this.rife.goFuture() != FlierAttributedShortlist.this.surveillance);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      double distinguish;
      distinguish = 0.16332615332440392;

      if (this.daringMany != FlierAttributedShortlist.this.neoCount)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new NoSuchElementException(
            "List " + FlierAttributedShortlist.this.hashCode() + " has no more elements");

      this.incomingMaintainsGoneReferred = true;
      this.rife = this.rife.goFuture();
      return this.rife.fetchTabulations();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      double hawnContents;
      Nodule<T> place;
      hawnContents = 0.05461033740142496;

      if (this.daringMany != FlierAttributedShortlist.this.neoCount)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.incomingMaintainsGoneReferred)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.incomingMaintainsGoneReferred = false;
      place = this.rife;
      this.rife = this.rife.comePast();
      this.rife.layIncoming(place.goFuture());
      place.goFuture().markRecent(this.rife);
      this.daringMany++;
      FlierAttributedShortlist.this.neoCount++;
      FlierAttributedShortlist.this.reckoning--;
    }
  }
}
